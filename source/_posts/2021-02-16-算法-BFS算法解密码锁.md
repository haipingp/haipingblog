---
title: 2021-02-16-算法-BFS算法解密码锁
date: 2021-02-16 16:42:49
categories:
- C++
---

## 一、用BFS解密码锁
### 1.1 算法需求
* 假设密码锁有四个圆形拨轮，每个拨轮有0-9共10个数字
* 四个转盘初始密码为“0000”，现在输入一个列表deadends和一个字符串target，其中target表示可以打开密码锁的数字，而deadends中包含了一组“死亡数字”，需要避免拨出其中任何一个密码
* 需要写一个算法，计算从初始状态`0000`到`target`的最少次数

<!--more-->

### 1.2 BFS算法 
* 因为各个密码之间没有依赖或排斥关系，所以这个算法即需要给出一个高效穷举密码的算法
* 我们一般尝试转锁的时候，一般从`0000`，转一次，可以转出`1000`, `9000`, `0100`, `0900`……共8中密码。然后再以这8种密码为基础，对每种密码再转一下，穷举所有可能。
* 上述这种穷举算法，抽象成图的话，即每个节点有8个相邻的节点，求最短距离。即一个`BFS算法`

* 代码:
``` cpp
string plusOne(string s, int j)
{
    if (j >= s.length()) return "";

    if (s[j] == '9') {
        s[j] = '0';
    } else {
        s[j] += 1;
    }
    return s;
}

string minusOne(string s, int j)
{
    if (j >= s.length()) return "";

    if (s[j] == '0') {
        s[j] = '9';
    } else {
        s[j] -= 1;
    }
    return s;
}

int openLock(vector<string> deadends, string target)
{
    // 记录需要跳过的死亡密码
    set<string> deads;
    for (auto& it : deadends)
    {
        deads.insert(it);
    }

    // 记录已经穷举过的密码，防止走回头路
    set<string> visited;
    queue<string> q;

    // 从起点开始广度优先搜索
    int step = 0;
    q.push("0000");
    visited.insert("0000");

    while (!q.empty())
    {
        int sz = q.size();
        // 将当前队列中的所有节点向周围扩散
        for (uint32_t i = 0; i < sz; i++)
        {
            string cur = q.front();
            q.pop();

            // 判断密码是否合法，是否到达终点
            if (deads.count(cur))
                continue;
            if (cur.compare(target) == 0)
                return step;

            // 将一个节点的未遍历相邻节点加入队列
            for (uint32_t j = 0; j < 4; j++)
            {
                string up = plusOne(cur, j);
                if (visited.count(up) == 0) {
                    q.push(up);
                    visited.insert(up);
                }
                string down = minusOne(cur, j);
                if (visited.count(up) == 0) {
                    q.push(down);
                    visited.insert(down);
                }
            }
        }
        step++;
    }
    return -1;
}
```

## 二、用双向BFS解密码锁

