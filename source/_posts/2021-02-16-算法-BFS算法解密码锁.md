---
title: 算法-BFS算法解密码锁
date: 2021-02-16 16:42:49
categories:
- C++
---

## 一、用BFS解密码锁
### 1.1 算法需求
* 假设密码锁有四个圆形拨轮，每个拨轮有0-9共10个数字
* 四个转盘初始密码为“0000”，现在输入一个列表deadends和一个字符串target，其中target表示可以打开密码锁的数字，而deadends中包含了一组“死亡数字”，需要避免拨出其中任何一个密码
* 需要写一个算法，计算从初始状态`0000`到`target`的最少次数

<!--more-->

### 1.2 BFS算法 
* 因为各个密码之间没有依赖或排斥关系，所以这个算法即需要给出一个高效穷举密码的算法
* 我们一般尝试转锁的时候，一般从`0000`，转一次，可以转出`1000`, `9000`, `0100`, `0900`……共8种密码。然后再以这8种密码为基础，对每种密码再转一下，穷举所有可能。
* 上述这种穷举算法，抽象成图的话，即每个节点有8个相邻的节点，求最短距离。即一个`BFS算法`

* 代码:
``` cpp
string plusOne(string s, int j)
{
    if (j >= s.length()) return "";

    if (s[j] == '9') {
        s[j] = '0';
    } else {
        s[j] += 1;
    }
    return s;
}

string minusOne(string s, int j)
{
    if (j >= s.length()) return "";

    if (s[j] == '0') {
        s[j] = '9';
    } else {
        s[j] -= 1;
    }
    return s;
}

int openLock(vector<string> deadends, string target)
{
    // 记录需要跳过的死亡密码
    set<string> deads;
    for (auto& it : deadends)
    {
        deads.insert(it);
    }

    // 记录已经穷举过的密码，防止走回头路
    set<string> visited;
    queue<string> q;

    // 从起点开始广度优先搜索
    int step = 0;
    q.push("0000");
    visited.insert("0000");

    while (!q.empty())
    {
        int sz = q.size();
        // 将当前队列中的所有节点向周围扩散
        for (uint32_t i = 0; i < sz; i++)
        {
            string cur = q.front();
            q.pop();

            // 判断密码是否合法，是否到达终点
            if (deads.count(cur))
                continue;
            if (cur.compare(target) == 0)
                return step;

            // 将一个节点的未遍历相邻节点加入队列
            for (uint32_t j = 0; j < 4; j++)
            {
                string up = plusOne(cur, j);
                if (visited.count(up) == 0) {
                    q.push(up);
                    visited.insert(up);
                }
                string down = minusOne(cur, j);
                if (visited.count(down) == 0) {
                    q.push(down);
                    visited.insert(down);
                }
            }
        }
        step++;
    }
    return -1;
}
```

## 二、用双向BFS解密码锁
* 上述的BFS算法是一棵树从root向下遍历查找的过程，双向BFS即从root向下遍历、同时从target向上遍历，当root的扩散结果和target的扩散结果有交集时，可以从两个方向遍历的层数推断出总共查找的步数

* 代码
``` cpp
int openLock(vector<string> deadends, string target)
{
    set<string> deads;
    for (auto& it : deadends)
    {
        deads.insert(it);
    }

    // 用集合可以快速判断元素是否存在
    set<string> q1;
    set<string> q2;
    set<string> visited;
    
    // 初始化起点和终点
    q1.insert("0000");
    q2.insert(target);
    int step = 0;

    while (!q1.empty() && !q2.empty())
    {
        // 用temp存储q1的扩散结果
        set<string> temp;

        // 将q1的所有节点进行扩散
        for (auto& cur : q1)
        {
            // 判断是否达到终点
            if (deads.count(cur)) {
                continue;
            }
            if (q2.count(cur)) {
                return step;
            }

            // 将未遍历相邻节点加入集合
            for (int j = 0; j < 4; j++)
            {
                string up = plusOne(cur, j);
                if (!visited.count(up))
                    temp.insert(up);
                string down = minusOne(cur, j);
                if (!visited.count(down))
                    temp.insert(down);
            }
        }

        // 增加步数
        step++;

        // 交换q1扩散结果temp和q2
        q1 = q2;
        q2 = temp;
    }
    return -1;
}
```
* 对于上述的双向bfs算法还可以进行优化: 每次在交换q1扩散结果temp和q2时，比较temp和q2的节点数，每次选择节点数较少的集合进行扩散，可以更快的计算出结果
