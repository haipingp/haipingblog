---
title: 备忘-git基础
date: 2021-03-10 11:28:25
categories: C++
---

## 一、简介
* 主要摘述和整理了这个博客的内容: http://www.linuxidc.com/Linux/2014-05/101829.htm
* Linus开发Linux内核，需要版本控制，于是开发了git
* 集中式管理和分布式管理区别:
	1. 集中式管理：从中央服务器取得最新版本，放在自己电脑，开始修改，修改好后提交到中央服务器；网速不好的话，可能无法提交大文件，影响工作。
	2. 分布式管理: 没有中央服务器，每个电脑都有完整的版本库，如果两台电脑在同一个局域网的话，甚至可以互相推送修改。即使服务器数据丢失，也可以用别的已经同步过版本号的电脑，获得版本信息。

<!--more-->

![集中式管理](central_server.png)
![分布式管理](distrubuted_server.png)

* git特点
	1. 分布式
	2. 存储快照而非差异
	3. 本地有完整的版本库，几乎所有操作都在本地
	4. 有内在一致性，SHA1
	5. 分支管理
	6. 支持各种协同模式
	7. 开源，一些第三方软件可整合使用

## 二、原理
* BLOB:每个blob代表一个（版本的）文件，blob只包含文件的数据，而忽略文件的其他元数据，如名字、路径、格式等
* TREE:每个tree代表了一个目录的信息，包含了此目录下的blobs，子目录（对应于子trees），文件名、路径等元数据。因此，对于有子目录的目录，git相当于存储了嵌套的trees
* COMMIT:每个commit记录了提交一个更新的所有元数据，如指向的tree，父commit，作者、提交者、提交日期、提交日志等。每次提交都指向一个tree对象，记录了当次提交时的目录信息。一个commit可以有多个（至少一个）父commits
* TAG:

![git基本类型](git_tree.png)
![git工作流程](workflow.png)

* 主要分为工作区(Working Dir)，提交区/暂存区(stage/index)，版本库

## 三、git配置
*  `git config`后加`--global`表示所有仓库都使用该配置:
``` 
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
```

## 四、git基本操作
* 新建空仓库: `git init`
* 在当前目录下新建一个`readme.txt`文件后，再使用`git status`查看，发现该文件是`untracked files`:
![新建文件](newfile.png)
* `git add`命令告诉git，需要把哪些文件提交到仓库，即将文件加入到暂存区(index)，执行`git add readme.txt`之后，再使用`git status`查看状态:
![添加文件](addfile.png)
* `git commit`命令将文件提交到版本库，提交结果如图所示，`1 file changed, 0 insertions(+), 0 deletions(-)`,增加了1个文件，没有对原有文件进行删除或增加。
![提交文件](commit_result.png)
* 再使用`git status`查看状态，说明已经没有改动可以提交:
![提交后状态](commit_status.png)

## 五、修改与回滚
* 在readme.txt中增加了一行，再使用`git status`查看:
![修改文件后的状态](modify_status.png)
* 再使用`git diff`查看改动的地方，发现是增加了一行:
![git diff查看改动](gitdiff.png)
* 对于以上改动，还是使用相同的方式，先`git add`，后`git commit`进行提交
* 多次提交后的log，可以通过`git log`或者`git log --pretty=oneline`进行查看:
![git log](gitlog.png)
![git log one line](gitlog_oneline.png)
* `HEAD`表示最新版本，往`HEAD`后加`^`表示向前推一个版本，几个`^`表示前推几个版本，同时，也可以使用log中的版本号标记一个版本。通过`git reset`命令回滚到某个版本。`--hard`表示回滚的同时，覆盖工作区文件，不写的话，只是将版本回滚结果放在暂存区:
![git reset](git_reset.png)
* 回滚后，结果如图:
![回滚后log](git_reset_result.png)
* 如果回滚后，又后悔了，可以找到原来最新的版本号，同样使用`git reset`回到原来最新的版本号。
* 如果已经关了窗口，找不到原来的版本号了，可以使用`git reflog`查找到执行过的命令，从中找到需要的版本号，再进行`git reset`

## 六、工作区、提交区/暂存区(index)和版本区
![不同区的结构](architecture.png)
* 工作区指的是跟`.git`文件夹平级的其他文件或目录
* 版本区在`.git`文件夹中
* 暂存区在`.git`文件夹的`index`文件夹中
* 左侧为工作区，右侧为版本库，版本库中`index`部分是暂存区，此时`HEAD`是指向master分支的一个指针
* 图中objects, 对象库，即`.git/objects`目录
* 执行`git add`之后，暂存区的目录树更新，同时工作区新增/修改的文件被写入到对象库的一个新的对象中，对象id在暂存区索引中
* 执行`git commit`之后，暂存区的目录树写到版本库的对象库中，master分支做相应更新。即master指向的目录树就是提交暂存区的目录树
* `git reset HEAD`, 暂存区的目录树被重写，被master指向的目录树替换, 工作区不受影响。
* `git rm --cached <file>`会从暂存区删除文件，工作区不作出改变
* `git checkout .`,`git checkout -- <file>`会用暂存区全部或指定文件替换工作区的文件，这个操作危险, 会清除工作区中未添加到暂存区的改动
* `git checkout HEAD .`, `git checkout HEAD -- <file>`会用HEAD指向的全部或部分文件替换暂存区及工作区文件。操作危险。

## 七、不同情况下的撤销修改
* 当改错工作区某个文件内容，想直接丢弃工作区的修改时，`git checkout -- <file>`
* 当改错工作区某个文件内容、并添加到暂存区时，想丢弃修改，分为两步，第一步，`git reset HEAD <file>`，回到第一步，第二步按第1步操作，执行`git checkout -- <file>`
* 当错误修改已提交到版本库，通过回滚方式回退版本，不过前提是没有推送到远程库
* 总结，以一篇博客的评论大致总结一下:原来git并不是用restore的，工作区的用checkout 放弃修改，添加后的用reset head 。这样做指令风险太大。reset的模式就很多。加入restore 就改变了很多，但离完美还差的远。 restore 是对指定区域撤销一步。 工作区域 撤销 git restore 文件名， 执行后 指针指向 Stage Head[0] || Repository Head[0] 短路或的作用，如果暂存区有新版本就直接用暂存区的版本，没有最新就用 仓库最新版本。实际上暂存区的 Head[0] 在没有新加文件都是指向仓库区的。 git restore --staged <file_name> 这个只是针对暂存区撤销一步，指针指向 Repository Head[0]，所以你无论添加多少次操作都是恢复到仓库最后一次提交的指针。

## 八、删除文件
* 删除工作区文件后，正常流程是通过`git rm`将该删除动作同步到暂存区，再进行`git commit`提交到版本库
* 如果误删，和上述撤销修改的操作道理差不多

