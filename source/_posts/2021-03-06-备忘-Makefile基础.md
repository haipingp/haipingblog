---
title: 备忘-Makefile基础
date: 2021-03-06 21:17:25
categories: C++
---

## 一、Makefile基础
* Makefile中的规则语法一般这样:
``` MAKEFILE
target ... : prerequisites ...
    command
    ...
    ...
```

* `$^`和`$@`分别表示依赖部分、目标部分

## 二、Makefile中的.d文件
### 2.1 简介
* Makefile有个隐晦规则，`.o`文件会自动查找同名的`.c`文件。比如有两个文件`first.c`，`main.c`，Makefile可以这样写:
``` make
OBJS:=first.o main.o
main:$(OBJS)
	gcc -o main $^
```
隐晦规则中，会加入`gcc -c *.c`，所以上面的Makefile可以工作。但是这种规则下，因为规则中没有写头文件，因此即使头文件修改了，也不会重新编译。所以写比较简单的make语句时，还是建议将头文件加进去。

* 那么有什么简单的方法在规则中加入头文件呢，`gcc -MM first.c`可以输出`first.o : first.c *.h `。因此可以把每个源文件`gcc -MM`到`.d`文件中，并在Makefile中include进来，相当于把这种依赖规则包含进来了，头文件变化的时候，头文件时间戳变化，Makefile会重新编译目标文件。

### 2.2 例子1
``` make
SRCS:=$(wildcard *.c) # SRCS为当前目录下的所有c文件名
OBJS=$(SRCS: .c=.o) # 后缀替换
.PHONY:all          # 表示all不是一个文件，即使存在一个文件名叫all，也不予理会
all:dep main
dep:
%.d:%.c
    rm -f $@;   # 删除原来的.d文件
    gcc -MM $< > $@    # 将MM结果定向到.d文件
    sed 's,/($*/)/.o[ :]*,/1.o $@ : ,g' < $@    # 用sed处理.d文件, $*用于匹配%的内容，[]里出现的空格和冒号都可以出现0到n次，最后第2个逗号和第3个逗号之间是匹配后的内容,/1表示匹配模式中括号内的内容
    
main:$(OBJS)
    gcc -o main $^
sinclude $(SRCS:.c=.d)    # 将.d文件中的依赖规则包含进来

clean:
    rm -f *.d *.o main
```

## 三、Makefile中的include命令
* 这一篇把include中的规则讲的比较清楚: `https://blog.csdn.net/q1449660223/article/details/111099765`
### 3.1 多个规则中存在相同目标，依赖更新时，目标都会更新
* 代码:
``` make
all:test

test:a.h
test:b.h
test:c.h
    @echo "hello ";
    touch test;
```
* 第一次运行:
![第一次运行结果](first_result.png)
* 第二次运行，因为没有文件更新，所以不更新:
![第二次运行结果](second_result.png)
* 多个规则具有相同目标时，目标中任意依赖文件更新，都会执行规则对应的命令：
![touch依赖文件后的运行](update_dep.png)

### 3.2 多个规则存在相同目标时，任意规则中依赖文件更新都会导致最后一条规则中的命令执行

* 代码：
``` make
all:test
 
test:a.h
    @echo "hello a.h";                                                     
test:b.h
    @echo "hello b.h";
test:c.h
    @echo "hello c.h";
    touch test;
```
* 结果：
![相同目标最后一条命令执行](last_valid.png)

### 3.3 include的工作流程
1. 创建一个文件`file.dep`，内容：
``` make
file.dep:a.h
```

2. Makefile：
``` make
all:test
sinclude file.dep
file.dep:b.h
    @echo "test:d.h" > file.dep;
test:c.h
    @echo "hello c.h";
    touch test; 
```

3. 依次输入以下内容后，结果:
![dep更新后make不生效](!dep_update_notvalid.png)  

4. 首先检查包含文件file.dep，检查是否有更新file.dep的规则，由于file.dep比b.h新，因此该规则不执行，包含file.dep结束，把file.dep中的内容`file.dep:a.h`包含进来，由于test比c.h新，因此最后没有命令执行

5. 确保以下文件存在：
![已有文件](init_files.png)

6. 依次输入以下命令，结果：
![最后的结果](final_results.png)

7. 最后touch test执行的原因：首先include命令将file.dep包含进makefile，检查是否有命令更新file.dep， 由于b.h比file.dep新，因此该规则命令执行，更新file.dep内容为`test:d.h`，重新包含file.dep内容；由于更新了d.h文件，`test:d.h`规则生效，最后依赖该规则执行最后的命令，test文件重新生成。

## 四、.a文件的链接
* 比如libtest.a，通过`-ltest`链接


