---
title: 算法-前序中序构造树
date: 2021-01-23 13:25:03
categories:
- C++
---

## 一、问题概述
* 通过前序和中序排列构造二叉树，问题如例1(`LeeCode 105`)所示

<!--more-->
![例1](例子1.png)

## 二、根据思路自己写的算法1
* 这个算法因为每次递归都会创建新的vector，占用内存太高
* 不过可以大致说明前序和中序的思路，如例2所示: 1. 根据每次前序遍历确定根节点的位置。因为前序遍历先访问的是根节点，所以前序遍历第一个位置就是根节点；2. 根据根节点在中序遍历中的位置，将树划分为左右两棵树；3. 根据第一步和第二步递归处理左右两棵树。
    ![例2](例子2.png)

    1. 根据前序遍历A B D E G C F H 确定根节点是A，根据中序遍历 D B G E A C H F 将树划分为左子树 D B G E 和右子树 C H F
    2. 划分为左右两棵子树：对于左子树，前序遍历是 B D E G，后续遍历是 D B G E。对于右子树，前序遍历是 C F H，后续遍历是 C H F
    3. 对左右子树进行第1 2步的递归分析，递归结束条件为：中序遍历的节点只剩下1个节点
* 代码：
``` cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty() || inorder.empty()) return nullptr;
        
        TreeNode* root = new TreeNode(preorder[0]);
        vector<int>::iterator it = find(inorder.begin(), inorder.end(), preorder[0]);
        int numsLeft = distance(inorder.begin(), it);
        
        if (numsLeft <= 0) {
            root->left = nullptr;   // 表示root没有左子树
        } else {
            vector<int> left_preorder(preorder.begin()+1, preorder.begin()+numsLeft+1); // 左子树前序
            vector<int> left_inorder(inorder.begin(), inorder.begin()+numsLeft);        // 左子树中序
            root->left = buildTree(left_preorder, left_inorder);
        }

        if (it+1 >= inorder.end()) {
            root->right = nullptr;  // 表示root没有右子树
        } else {
            vector<int> right_preorder(preorder.begin()+numsLeft+1, preorder.end());    // 右子树前序
            vector<int> right_inorder(it+1, inorder.end());     // 右子树中序
            root->right = buildTree(right_preorder, right_inorder);
        }
        return root;
    }
};
```
* 由于`left_preorder left_inorder right_preorder right_inorder`都是每次递归新创建的vector，因此随着递归层数增加，会增加内存，所以占用内存很多
* 当时思路局限在LeeCode题目的接口参数上了，没想到接口参数传入数组的索引

## 三、优化：根据索引分左右子树，进行递归
``` cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
    {
        return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

    TreeNode* buildTree(vector<int>& preorder, int pre_start, int pre_end, vector<int>& inorder, int in_start, int in_end) 
    {
        if (pre_start > pre_end || in_start > in_end) {
            return nullptr; 
        }
        TreeNode* root = new TreeNode(preorder[pre_start]);
        vector<int>::iterator it = find(inorder.begin(), inorder.end(), preorder[pre_start]);
        int rootpos = distance(inorder.begin(), it);
        int numleft = distance(inorder.begin()+in_start, it);

        root->left = buildTree(preorder, pre_start+1, pre_start+numleft, inorder, in_start, in_start+numleft-1);
        root->right = buildTree(preorder, pre_start+numleft+1, pre_end, inorder, rootpos+1, in_end);
        return root;
    }
};
```

## 四、针对题中没有重复元素的优化
``` cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
    {
        map<int, int> inmap;
        int i = 0;
        for (auto& it : inorder)
        {
            inmap[it] = i; 
            i++;
        }
        return buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, inmap);
    }

    TreeNode* buildTree(vector<int>& preorder, int pre_start, int pre_end, vector<int>& inorder, int in_start, int in_end, map<int, int>& inmap) 
    {
        if (pre_start > pre_end || in_start > in_end) {
            return nullptr; 
        }
        TreeNode* root = new TreeNode(preorder[pre_start]);
        vector<int>::iterator it = find(inorder.begin(), inorder.end(), preorder[pre_start]);
        int rootpos = inmap[root->val];
        int numleft = rootpos - in_start;

        root->left = buildTree(preorder, pre_start+1, pre_start+numleft, inorder, in_start, in_start+numleft-1, inmap);
        root->right = buildTree(preorder, pre_start+numleft+1, pre_end, inorder, rootpos+1, in_end, inmap);
        return root;
    }
};
```
* 哈哈，本来想用map存储inorder中的值和索引的，发现leecode上跑出来的速度没有提高多少，但是内存增加了20%
