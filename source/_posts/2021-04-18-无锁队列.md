---
title: 无锁队列
date: 2021-04-18 22:07:52
categories: C++
---

## 一、简介
如果使用锁来确保多线程访问时数据的一致性，当加解锁变得频繁时，比较耗时，因此需要找到一种无锁队列解决这个问题。举个现实中的例子，在一个四岔路口，如果朝南和朝北的车辆可以同时在开的话，容易发生交通事故，因此，需要在这些路口安放红绿灯。
这样朝南行驶的车放行时，朝北的车辆不能行驶。为了更高效的通过这个路口，采用了环岛使所有的车辆可以进入环岛来通行，如果有秩序的话，其实不设置红绿灯，也不会产生冲突。
这就好像用原子操作实现的无锁队列，不再有红绿灯值守。

<!--more-->

## 二、使用原子操作的无锁队列
* 需要用到的原子操作，CAS(compare and swap):
	```
	bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)
	type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)
	These builtins perform an atomic compare and swap. That is, if the current value of `*ptr` is `oldval`, then write `newval` into `*ptr`.
	The “bool” version returns true if the comparison is successful and newval was written. The “val” version returns the contents of *ptr before the operation.
	```
* 比如入队列操作：
	``` cpp
	do {
		p = ctx->tail;
		if ( __sync_bool_compare_and_swap(&ctx->tail, p, tmpnode)) {	// 这一步是原子操作，两个线程同时执行到这一句时，其中一个线程判断并赋值后，另一个就判断不通过
			p->next=tmpnode;
			__sync_add_and_fetch( &ctx->count, 1);
			break;
		}
		// cas操作不成功的线程，会继续进入循环进行判断，直至判断成功
	} while(1);
	```
* 这里只是简单地讲了下无锁队列，关于无锁队列，有个pdf貌似是本书。所以在后面贴了几个链接，有空慢慢看

## 三、总结与心得
* 写博客如果能写的跟第一个链接一样容易懂就好啦
 
## 四、参考链接
`https://www.schneems.com/2017/06/28/how-to-write-a-lock-free-queue/`
`https://www.internalpointers.com/post/lock-free-multithreading-atomic-operations`
`https://www.codeproject.com/Articles/23317/Lock-Free-Queue-implementation-in-C-and-C`

