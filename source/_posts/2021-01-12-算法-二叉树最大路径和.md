---
title: 算法-二叉树最大路径和
date: 2021-01-12 20:59:03
categories:
- C++
---

## 一、问题概述
该算法题在LeeCode上序号为124，给出一个算法，能够返回一个二叉树的最大路径和(路径和指的是二叉树的路径上，每个节点值的和)。

<!-- more -->
以下是两个例子：
![例1](例子1.png)

![例2](例子2.png)

## 二、解法1
### 代码
``` cpp
class Solution {
public:
    long ans;
    long max(long ans,int p) {
        return (p>ans)?p:ans;
    }
    int solution(TreeNode* root) {
        if(!root) return 0;
        int p=INT_MIN,q=INT_MIN;
        p=solution(root->left);
        q=solution(root->right);
        ans=max(ans,p+q+root->val);   // 加到任意一个值都取最大的那个和 
        p=max(p,q)+root->val;
        if(p<0) return 0;   // 舍弃小于0的子节点(子树)，因为负数只会越加越小
        return p;
    }
    int maxPathSum(TreeNode* root) {
        ans=LONG_MIN;
        solution(root);
        return ans;
    }
```

### 解析
1. 因为路径不可以绕圈，因此经过每个root的时候，只能选择经过二叉树中的一个子节点，所以这个问题变成了: 比较左右子树的路径和，选择保留左子树还是右子树，并且在路径遍历过程中，记录目前的路径可以达到的最大的和。  
2. 需要先分别计算左右子树的最大路径和，再加上root的节点值，才能计算最终最大路径和，因此采用后序遍历
3. 这里因为需要有比较操作，因此需要在起始处设置int或long的最小值，才能进行比较，因此题中也给出了节点值和节点数的范围
4. 这里ans用于记录目前路径可以达到的最大和，比如当前root的值为负数，ans则越加越小，就不会将该root加进去
5. `p=max(p,q)+root->val;if(p<0) return 0;`，前一句，当走到某个选择路口root时，选择一个值较大的路p或q；后一句，如果选择了之后，只能让结果p变得更小，那么选择放弃这个子节点(子树)

## 三、解法二
### 代码
``` cpp
int ans = INT_MIN;
int oneSideMax(TreeNode* root) {
    if (root == nullptr) return 0;

    int left = max(0, oneSideMax(root->left));
    int right = max(0, oneSideMax(root->right));

    ans = max(ans, left + right + root->val);
    return max(left, right) + root->val;
}
```
### 解析
1. 这种解法和前一种是同一种思路，只是写法不同，解法1将舍弃子节点(子树)操作放在递归return前，解法2将舍弃子节点(子树)放在递归return刚刚回来的时候
2. 但是自己更倾向于前一种，在递归return前把该作的各种计算都做好了，递归回来只单纯用方法名Solution就可以了，思路比较干净明了


