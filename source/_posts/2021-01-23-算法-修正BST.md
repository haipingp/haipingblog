---
title: 2021-01-23-算法-修正BST
date: 2021-01-23 17:02:52
categories:
- C++
---

## 一、问题概述
* 二叉搜索树中有一对节点，swap by mistake，需要找出这一对节点进行修正，如`BST 1`和`BST 2`所示

<!--more-->

![BST 1](bst1.png)
![BST 2](bst2.png)

## 二、解决思路
* BST的一个特点是，中序遍历得到的结果是按大小顺序排列的
* 由于题目中只有一对节点发生了错误，这一对节点即，第1个大于当前root的节点和最后1个小于root的节点。因此可以按照这个思路寻找并纠正。

## 三、代码
``` cpp
class Solution {
public:
    TreeNode* prev = nullptr;
    TreeNode* first = nullptr;
    TreeNode* second = nullptr;

    void recoverTree(TreeNode* root) {
        tranverse(root);
        if (!first || !second)
            return;
        int temp = first->val;
        first->val = second->val;
        second->val = temp;
    }

    void tranverse(TreeNode* root) 
    {
        if (!root)
            return;

        tranverse(root->left);      // 遍历左子树

        if (prev && root->val < prev->val) {
            if (!first)
                first = prev;       // 找到第1个大于当前root的节点
            second = root;          // 找到最后1个小于前面的值的节点
        }

        prev = root;

        tranverse(root->right);
    }
};
```

## 四、对于自己的难点
* 自己没想到思路，虽然看到中序遍历的思路，但是直接从这个思路为入口思考，有点舍本逐末的感觉。一直在想怎么中序遍历可以找到结果，却很难想到
* 应该从问题本身开始思考，只有两个节点是错误的，参考BST本身的特点，如何找到这两个节点

## 五、从两个例子比较容易找到思路
* 从`BST 3`可以直观地看到1和3节点是错误的，并且看到一个特点，由于只有一对节点有问题，因此3节点比1节点大的错误特性是沿着路径2一直到1节点的。所以可以从条件`root->val < prev->val`找到第一个不对的节点3和最后一个不对的节点1;
* 从`BST 4`可以直观地看到1和3节点是错误的，并且有个特点，由于只有一对节点有问题，因此3节点比1节点大的错误是沿着路径2一直到3节点的。所以可以从条件`root->val < prev->val`找到第一个不对的节点3和最后一个不对的节点1;

<img src="bst3.jpg" alt="BST 3" width="250"/>
<img src="bst4.jpg" alt="BST 4" width="250"/>


* `BST 3`和`BST 4`的递归过程如`BST deduction 1`和`BST deduction 2`所示，这样看得懂一些
![BST deduction 1](deduction1.jpg)
![BST deduction 2](deduction2.jpg)

