---
title: Redis中的字符串sds
date: 2021-04-24 16:29:19
categories:
- C++
- redis
---

## 一、sds的一些特征
1. binary safe, 由于sds实现中都采用的是内存的分配和拷贝等，没有使用string，因此是二进制安全的。在创建字符串时会自动在结尾加`\0`，因此也可以通过printf打印出来。同时，也因为是二进制安全的，即使在字符串中间插入了`\0`，sds也保存了整个字符串的长度，不会丢失后面的数据。

<!-- more -->

## 二、sds实现
``` cpp
sds sdsnewlen(const void *init, size_t initlen);
```
* 用于创建sds字符串，这里主要是分配了内存，分配内存时，根据平台不同，分为两类。一类是自己可以查询到分配的内存大小的，在redis的内存管理中，可以直接调用这些平台的内存管理接口。一类是没有对外的可以查询分配内存大小的变量的，需要用一个PREFIX_SIZE来自己存储分配内存大小，从而进行内存管理。
* 将内存管理的库分为两类后，通过宏定义HAVE_MALLOC_SIZE和zmalloc_size等，通过统一的接口进行内存管理。
* 需要自己管理分配内存大小的一类，这个size放在sdshdr结构地址之前，可以通过地址偏移获取到。

``` cpp
sds sdscatvprintf(sds s, const char *fmt, va_list ap);
```
* 用于输出fmt和ap指定的可变参数字符串到s。
* 分配内存时，如果设置的1024字节的栈内存够用的话，直接使用栈内存，如果不够用，申请堆内存。
* 用于输出的buff，每次都在`buflen-2`的位置首先设置`\0`，如果后面拷贝内存时被覆盖了，说明buff不够长，申请len*2的内存大小。
* 这里选用`buflen-2`位置是因为，vsnprintf函数会在执行时在fmt和cpy组合成的字符串的最后加`\0`，如果是在`buflen-1`位置设置null char，即使buff不够长，这个位置也会被填充为null char，因此不能作为是否buff足够长的判断。


